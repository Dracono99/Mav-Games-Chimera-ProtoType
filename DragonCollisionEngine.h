#pragma once

#include "DragonContactResolver.h"
#include "HydraOctrees.h"
#include <vector>

class DragonCollisionEngine
{
private:
	// this is a pointer to the contact resolver class
	// it resolves contacts generated by the collision detector / contact generator
	DragonContactResolver* m_cpContactResolver;
	// this is the collision detector / contact generator it does both or rather this is a pointer to it
	DragonContactGenerator* m_cpContactGenerator;
	// this is a pointer to the parent node of the octree
	HydraOctree* m_cHydraSpaceOptimization;
public:
	// default constructor theres no need for a parameterized one
	DragonCollisionEngine();
	// destructor needed to delete pointers and eliminate memory leaks
	// also note its not virtual as no class inherits from this one
	~DragonCollisionEngine();
	// this will generate contacts from a list of entities
	void GenerateContacts(std::vector<BaseGameEntity*>& entities);
	// this returns the internal list of contacts however because the collision engine doesn't stare the contacts at the moment
	// this is un used but can be used if found needed
	std::vector<DragonContact*> GetContactList();
	// this is currently used for debugging but can and will likely be used for game play aswell
	// this will perform collision detection and contact generation on the given list of entities
	// then return the vector of contacts to be used by other things in my case i render contacts via contact point and normal
	// but other uses may be found one theory is to use these in conjunction with trigger volumes that is
	// keep a list of trigger volumes and their associated triggered effects to be applied or perhaps only send a message when a contact with a trigger volume is
	// detected and returned
	std::vector<DragonContact*> GetListOfContactsFromList(std::vector<BaseGameEntity*>& entities);
	// this can be used to resolve the internal and currently un used vector of contacts
	void ResolveContacts(real dt);
	// gets a pointer to the octree object
	HydraOctree* getHydra(){return m_cHydraSpaceOptimization;}
	// gets a pointer to the contact resolver
	DragonContactResolver* getResolver(){return m_cpContactResolver;}
	// gets a pointer to the contact generator
	DragonContactGenerator* getGenerator(){return m_cpContactGenerator;}
	inline void ClearContacts()
	{
		if (m_cpContactGenerator->registry->m_vContactPairs.size()>200)
		{
			m_cpContactGenerator->registry->ClearPairs();
		}		
		m_cpContactGenerator->registry->ClearContacts();
	}
};
